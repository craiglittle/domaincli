#!/usr/bin/env python
import logging
import optparse
import os
import re
import sys
import textwrap
import urllib
import urllib2
import urlparse

import ConfigParser

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class Error(Exception):
    pass

class DomainCLIError(Exception):
    pass

class RPC(object):
    # Yeah yeah yeah, I know.  I'll buy an SSL cert for domaincli.com soon.
    # URL = 'https://getpokebot.com:7000/v1'
    URL = 'http://localhost:8000/v1'

    # Stolen from Stripe
    def _encodeInner(self, d):
        """
        We want post vars of form:
        {'foo': 'bar', 'nested': {'a': 'b', 'c': 'd'}}
        to become:
        foo=bar&nested[a]=b&nested[c]=d
        """
        stk = []    
        for key, value in d.items():
            if isinstance(value, dict):
                n = {}
                for k, v in value.items():
                    n["%s[%s]" % (key, k)] = v
                    stk.extend(self._encodeInner(n))
            else:
                stk.append((key, value))
        return stk

    # Stolen from Stripe
    def _encode(self, d):
        """
        Internal: encode a string for url representation
        """
        return urllib.urlencode(self._encodeInner(d))

    def call(self, name, args={}):
        args['method'] = name
        serialized = self._encode(args)
        try:
            c = urllib2.urlopen(self.URL, serialized)
        except urllib2.URLError, e:
            raise DomainCLIError("Unexpected error while talking to server: %s" % (e, ))
        resp = c.read()
        resp = urlparse.parse_qs(resp, strict_parsing=True)
        for k, v in resp.items():
            resp[k] = v[0]
        logging.debug('Result: %r' % resp)
        if resp['object'] == 'error':
            raise DomainCLIError(resp['message'])
        return resp

### Valid subprograms
def check(parser, rpc, opts, args):
    if len(args) == 0:
        parser.print_help()
        return 1
    config = load_config(parser, rpc, opts, args)
    for arg in args:
        before_rpc('Checking status of %s...' % (arg, ))
        sys.stdout.flush()
        res = rpc.call('check_availability', { 'domain' : arg })
        if res['available'] == 'True':
            after_rpc_success('Available!')
        else:
            after_rpc_failure('Taken :(!')

def register(parser, rpc, opts, args):
    if len(args) == 0:
        parser.print_help()
        return 1
    config = load_config(parser, rpc, opts, args)
    nameservers = get_nameservers(config, parser, rpc, opts, args)
    for arg in args:
        before_rpc('Trying to register %s...' % arg)
        res = rpc.call('register_domain', { 'domain' : arg, 'nameservers' : nameservers })
        if res['success'] == 'True':
            after_rpc_success('success!')
        else:
            after_rpc_failure('failure!')
        print ' \-->', res['message']


### Output
def before_rpc(msg):
    print msg,
    sys.stdout.flush()

def after_rpc_success(msg):
    print msg

def after_rpc_failure(msg):
    print msg

### Config
def get_nameservers(config, parser, rpc, opts, args):
    nameservers = opts.nameservers
    if not nameservers:
        try:
            nameservers = config.get('DomainCLI', 'nameservers')
        except ConfigParser.NoOptionError:
            pass
    while True:
        if nameservers and not re.search('^[a-zA-Z0-9 .,-]+$', nameservers):
            print "Uh-oh: There are invalid characters in the nameservers I'm about to use (%r)" % nameservers
            print "Nameservers can only be domain names and IP addresses."
            print "Mind helping me out?"
            nameservers = None
        if nameservers:
            return nameservers
        if len(args) == 1:
            dom = 'this domain'
        else:
            dom = 'these domains'
        print 'What nameservers would you like to use for %s?' % dom
        print "(HINT: If you're not sure, run 'dig NS <yourotherdomain>'"
        print " to find what nameservers you are using elsewhere)"
        print 'Please give me a comma-separated list of nameservers; then press enter.'
        inp = raw_input('Nameservers: ')
        nameservers = ', '.join([ns.strip() for ns in inp.split(',')])
        config.set('DomainCLI', 'nameservers', nameservers)
        save_config(config, parser, rpc, opts, args)

def save_config(config, parser, rpc, opts, args):
    path = os.path.expanduser(opts.config_file)
    # TODO: atomic write?  Getting that right is always kind of tricky.
    config.write(open(path, 'w'))

def load_config(parser, rpc, opts, args):
    config = ConfigParser.ConfigParser()
    path = os.path.expanduser(opts.config_file)
    if os.path.exists(path):
        loaded = True
        f = open(path)
        config.readfp(f)
    else:
        loaded = False

    try:
        config.get('DomainCLI', 'user_id')
    except (ConfigParser.NoSectionError, ConfigParser.NoOptionError):
        pass
    else:
        return config

    if loaded:
        msg = ("It appears your config file\n"
               "%s\n"
               "does not contain a valid user ID.\n"
               "I'm going to generate a new ID for\n"
               "you.  Feel free to replace this new\n"
               "user ID with an existing one, if you\n"
               "have one." % opts.config_file)
    else:
        msg = ("Looks like this is your first time running DomainCLI\n"
               "If you'll prdon the brief interruption, I'm going to\n"
               "create a user ID for you and automatically save it to\n"
               "%s" % opts.config_file)
    print '->', '\n-> '.join(textwrap.wrap(msg))
    before_rpc('-> Generating user ID...')
    res = rpc.call('domaincli_create_account')
    after_rpc_success('done!')
    config.add_section('DomainCLI')
    config.set('DomainCLI', 'user_id', res['id'])
    save_config(config, parser, rpc, opts, args)
    print("-> For your information, your user ID is\n"
          "->  %s\n" % res['id'])
    return config

def main():
    programs = {'check' : check,
                'register' : register}
    idx = prog = None
    proper_args = sys.argv[1:]
    for i, arg in enumerate(proper_args):
        if len(arg) == 0 or arg[0] != '-':
            idx = i
            prog = arg
            break
    if idx is not None:
        args = proper_args[:idx] + proper_args[idx+1:]
    else:
        args = sys.argv

    if prog == 'check':
        parser = optparse.OptionParser("""%prog [options] check domain [domain...]""")
    elif prog == 'register':
        parser = optparse.OptionParser("""%prog [options] register domain [domain...]""")
        parser.add_option('-s', '--name-server', help='Nameservers for registered domain [can pass multiple times. Defaults to list in config file]',
                          dest='nameservers', action='append', default=[])
    else:
        prog = None
        parser = optparse.OptionParser("""%%prog [options] %s""" % '|'.join(programs.iterkeys()))
    parser.add_option('-v', '--verbosity', help='Verbosity of debugging output.',
                      dest='verbosity', action='count', default=0)
    parser.add_option('-f', '--config-file',
                      help='Location of config file (default: ~/.domaincli)',
                      dest='config_file', default='~/.domaincli')
    opts, args = parser.parse_args(args)

    if opts.verbosity == 1:
        logging.getLogger('').setLevel(logging.INFO)
    elif opts.verbosity >= 2:
        logging.getLogger('').setLevel(logging.DEBUG)
    try:
        method = programs[prog]
    except KeyError:
        parser.print_help()
        return 1
    else:
        rpc = RPC()
        logger.debug('About to call %s with %r / %r' % (prog, opts, args))
        return method(parser, rpc, opts, args)

if __name__ == '__main__':
    sys.exit(main())
